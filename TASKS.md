# Tasks & Work Log

## Now
- See **NEXT_IMPROVEMENTS.md** for comprehensive roadmap of planned enhancements (pose robustness, age model upgrade, deep feature embeddings, occlusion handling)

## Done (recent)
- **Implemented gender-specific age calibration (9.9% improvement)**:
  - Created `web/scripts/fit-gender-calibration.mjs` to fit separate male/female calibration curves
  - Split 144 UTKFace samples by gender (67 male, 76 female) and fitted independent 3-segment piecewise regressions
  - Male calibration: MAE 11.66 years (thresholds: 29.7, 44.3)
  - Female calibration: MAE 14.09 years (thresholds: 49.7, 54.8)
  - Combined MAE: 13.15 years vs 14.59 years unified (1.44 year improvement, 9.9% reduction)
  - Updated `web/src/lib/age-estimation.ts` with dual constants (AGE_CALIBRATION_MALE, AGE_CALIBRATION_FEMALE)
  - Modified `calibratePredictedAge()` to accept gender parameter and select appropriate curve
  - Updated `estimateAge()` to pass predicted gender to calibration function
  - Updated all unit tests in `age-estimation.test.ts` to test both gender curves independently
  - All 236 tests passing (19 age estimation tests, including gender-specific calibration tests)
  - Gender-specific calibration reduces systematic bias in age estimation across demographics
  - Next step: Age model upgrade for further improvement (current 13.15y MAE → target <5y MAE for adults)
- **Completed 3-segment piecewise age calibration**:
  - Collected 143 UTKFace samples through browser pipeline (face detection + IPD crop)
  - Fitted 3-segment piecewise linear regression for better age range coverage
  - Final MAE: 14.6 years overall (Children 14.6y, Teens 6.3y, Young Adults 8.7y, Middle Age 19.2y, Seniors 33.8y)
  - Thresholds: 30.6 (low→mid) and 49.7 (mid→high)
  - Updated constants in `web/src/lib/age-estimation.ts`
  - Created comprehensive calibration tooling:
    - `web/src/app/calibrate/page.tsx` - Manual calibration UI
    - `web/scripts/batch-calibrate.mjs` - Playwright automation for batch data collection
    - `web/scripts/fit-calibration.mjs` - Multi-model regression fitting (linear, polynomial, 2-segment, 3-segment)
    - `scripts/select-from-extracted.mjs` - Image selection for diverse age coverage
    - `scripts/select-children.mjs` - Child-specific image selection
  - Analyzed raw prediction variance to identify model limitations vs calibration issues
  - Documented findings: Very young children (0-2) have high model variance (CV 34-40%) indicating model limitation
  - Files: `calibration-data-all.csv` (143 samples), `calibration-results.json`, `AGE_CALIBRATION_PLAN.md`
  - Identified next steps: gender-specific calibration and/or age model replacement for further improvements

## Done (recent)
- **Age calibration fixtures:** Added UTKFace-stratified sample set (ages 1-116 with 0-9 coverage), copied 55 images into `web/src/__tests__/fixtures/age-calibration/`, and generated `metadata.json` entries via `scripts/ingest-utkface.mjs` with added 3-9 year samples for decade balance.
- Age evaluation harness: produces MAE/RMSE plus linear, quadratic, segmented calibrations; segmented fit currently best (MAE 24.7) and applied to runtime age estimator.
- Added `scripts/estimate-age-pair.mjs` CLI to run age estimation on two arbitrary images (raw + calibrated ages, gender predictions, gap).
- Baseline age estimation evaluation harness (`scripts/evaluate-age-estimator.mjs`) with MAE/RMSE per-decade report and JSON results.

-- **UI optimization: full-width feature analysis with prominent congruence display**:
  - Moved `FeatureDetailPanel` outside two-column grid to span full page width (constrained only by page max-w-6xl)
  - Repositioned overall congruence score as dedicated section at top of panel (large 2xl font, border separator)
  - Added per-feature congruence percentages next to each feature name
  - Implemented descending sort by congruence score (most similar features appear first)
  - Simplified label from "Overall Morphological Congruence" to "Overall Congruence"
  - Updated tests to match new UI structure
  - Files modified: `app/page.tsx` (panel positioning), `FeatureDetailPanel.tsx` (layout, sorting, scoring display), `feature-detail-panel.test.tsx` (test assertions)
  - Eliminates vertical space waste by using full screen width for detailed analysis
- **Expanded morphological features from 4 to 8 categories with horizontal layout**:
  - Added 4 new feature categories: brows (shape, position, length), cheeks (prominence, nasolabial depth, height), forehead (height, contour), face shape (length-width ratio, facial thirds)
  - Implemented 12 new classification functions in `axis-classifiers.ts` for new measurement axes
  - Added measurement extraction functions in `feature-axes.ts` for all new features
  - Updated `feature-comparisons.ts` to compare all 8 features instead of 4
  - Enhanced `FeatureDetailPanel.tsx` with horizontal flex layout for shared/A/B sections on desktop (md+ breakpoint)
  - Updated all test mocks to include 8 features - 179/180 tests passing
  - Fixed unused import in `parsing-adapter.ts` (removed PARSING_ENABLED)
  - Commit: 19476ad "feat(analysis): expand morphological features from 4 to 8 categories with horizontal layout"
  - Files modified: `feature-axes.ts`, `axis-classifiers.ts`, `feature-comparisons.ts`, `FeatureDetailPanel.tsx`, test files
  - +739 lines, -46 lines across 7 files
- **Implemented Phase 6: UI for detailed feature narratives**:
  - Created `web/src/components/FeatureDetailPanel.tsx` with expandable feature sections
  - Displays morphological congruence score at top level
  - Shows overall narrative summarizing face similarity
  - Presents shared characteristics (common axes where both faces agree)
  - Features (eyes, nose, mouth, jaw) expand to reveal axis-by-axis details
  - Single-feature expand/collapse interaction (one open at a time)
  - State management in `page.tsx` captures `featureNarrative` and `congruenceScore` from worker
  - Added comprehensive unit tests: `feature-detail-panel.test.tsx` (10 tests)
  - All tests passing (179/180, with 1 pre-existing parsing-adapter failure)
  - Files created: `components/FeatureDetailPanel.tsx`, `__tests__/feature-detail-panel.test.tsx`
  - Files modified: `app/page.tsx` (state + imports)
  - End-to-end flow: worker computes narratives → page captures → component displays

- **Implemented Phase 5: Worker integration + simultaneous parsing** (FEATURE_AXES_PLAN.md):
  - Refactored worker to parse both images simultaneously using `Promise.all()` for better performance
  - Integrated detailed feature axis analysis into worker pipeline
  - Extracts measurements, classifies features, performs comparisons, generates narratives
  - Returns `featureNarrative` with overall assessment, feature summaries, and detailed axis-by-axis descriptions
  - Returns `congruenceScore` (0-1) for overall morphological similarity
  - Updated `web/src/workers/types.ts` with `FeatureNarrative` type definition
  - All feature analysis wrapped in try-catch for graceful degradation
  - Logs congruence score and shared axes count in development mode
  - Files modified: `analyze.worker.ts` (simultaneous parsing + analysis integration), `types.ts` (new types)
  - All 169/170 tests passing (1 pre-existing parsing-adapter failure unrelated to changes)
- **Implemented Phase 3 of detailed feature axis analysis** (FEATURE_AXES_PLAN.md):
  - Created `web/src/lib/feature-comparisons.ts` with axis comparison functions
  - Compares two faces across all 16 axes to determine agreement/disagreement
  - Computes similarity scores based on raw measurements (0-1 scale)
  - Calculates percentage differences and direction (higher/lower)
  - Generates overall agreement scores per feature category
  - Provides morphological congruence score (overall similarity metric)
  - Includes shared axis values and feature agreement summaries
  - Created `web/src/lib/feature-narratives.ts` with natural language generation
  - Generates human-readable descriptions for each axis comparison
  - Creates feature-level summaries (e.g., "Eyes are highly similar")
  - Produces overall narrative with morphological congruence assessment
  - Supports dimensional comparisons (e.g., "Subject A's nose is 8% wider")
  - Includes contrast narratives highlighting specific differences
  - Added comprehensive unit tests: `feature-comparisons.test.ts` (19 tests) and `feature-narratives.test.ts` (25 tests)
  - All tests passing (170/170 total including 44 new comparison/narrative tests)
  - Files created: `lib/feature-comparisons.ts`, `lib/feature-narratives.ts`, `__tests__/feature-comparisons.test.ts`, `__tests__/feature-narratives.test.ts`
- **Implemented Phase 1 & 2 of detailed feature axis analysis** (FEATURE_AXES_PLAN.md):
  - Created `web/src/lib/feature-axes.ts` with landmark-based measurement extraction functions
  - Extracts 16 detailed measurements across 4 feature categories: eyes (3 axes), nose (3 axes), mouth (5 axes), jaw (5 axes)
  - Measurements include: canthal tilt, eye size, interocular distance, nose width, bridge contour, tip projection, lip fullness, cupid's bow, lip corners, philtrum length, mouth width, jaw width, mandibular angle, chin projection, chin width, symmetry
  - All measurements normalized by IPD or face width for robust cross-face comparison
  - Created `web/src/lib/axis-classifiers.ts` with threshold-based classification system
  - Maps raw measurements to categorical descriptors (e.g., "positive", "narrow", "full", "prominent")
  - Includes confidence scores (0-1) based on distance from threshold boundaries
  - Thresholds based on anthropometric literature and typical facial proportions
  - Added comprehensive unit tests: `feature-axes.test.ts` (19 tests) and `axis-classifiers.test.ts` (35 tests)
  - All tests passing (126/126 total including 54 new axis tests)
  - Files created: `lib/feature-axes.ts`, `lib/axis-classifiers.ts`, `__tests__/feature-axes.test.ts`, `__tests__/axis-classifiers.test.ts`
- **Documented feature axis plan in FEATURE_AXES_PLAN.md**:
  - Comprehensive specification for 40+ facial feature axes across 8 categories
  - Detailed implementation plan with 6 phases (weeks 1-4)
  - Landmark mappings for each measurement using MediaPipe FaceMesh indices
  - Testing strategy and success criteria
  - Referenced in AGENTS.md and CLAUDE.md for future development work
- **Fixed segmentation convex hull merging disconnected regions (third iteration - FINAL)**:
  - Root cause: The segmentation model sometimes misclassifies a few pixels of class 6 (l_brow) on the right eyebrow, or class 7 (r_brow) on the left eyebrow
  - When `maskToOutline()` computed the convex hull of ALL class 6 pixels, it wrapped around BOTH eyebrows because there were scattered pixels on both sides
  - This created a large polygon spanning from left to right across the face, wrapping both eyebrows
  - Solution: Added `largestConnectedComponent()` function to `lib/mask.ts` using flood-fill algorithm
  - Now `maskToOutline()` first extracts the largest connected component before computing the convex hull
  - This ensures each eyebrow gets its own separate outline, even if there are a few misclassified pixels
  - Uses 4-connected flood fill to find all connected regions, then keeps only the largest one
  - Modified `maskToOutline()` to call `largestConnectedComponent()` before `pointsFromMask()`
  - Each segmentation class now generates a single, localized outline following the largest cluster of pixels
- **Fixed worker to prevent duplicate brows/nose outlines (second iteration)**:
  - Root cause was deeper than initially thought: landmark-based nose outlines were ALSO being added before adapter hints
  - The nose generation code (lines 185-196) was pushing alar arc + bridge outlines directly to polys array
  - When adapter provided nose hints (classId=2), we ended up with BOTH landmark nose AND segmentation nose
  - Solution: Changed nose generation to store in variables (noseAlar, noseBridge) instead of immediately pushing to polys
  - Added conditional logic to only use landmark nose if adapter doesn't provide `hasNose`
  - Now both brows AND nose follow the same pattern: generate landmark fallbacks but only use them if adapter doesn't provide them
  - Modified `compute Outline Polys()` in `analyze.worker.ts` to check `hints.some(h => h.region === 'nose')` before adding landmark fallback
  - Each segmentation-based outline (l_brow=6, r_brow=7, nose=2) now displays independently without merged or duplicate landmark-based outlines
- **Fixed worker to prevent duplicate brows/nose outlines (first iteration)**:
  - Root cause: Worker was adding landmark-based brows to polys array BEFORE attempting to override with adapter hints
  - Even though adapter removal code existed, the landmark brows were already in the array and weren't being removed
  - Solution: Changed worker to skip adding landmark brows initially, only add adapter hints, then fallback to landmark brows only if adapter didn't provide them
  - Modified `computeOutlinePolys()` in `analyze.worker.ts` to check `hints.some(h => h.region === 'brows')` before adding landmark fallback
  - Eliminated the merged "big outline around both eyebrows" issue - now only individual segmentation-based outlines are displayed
  - Each bilateral feature (left/right brow, left/right eye) now displays independently without duplicate merged outlines
- **Fixed Transformers.js adapter to generate segmentation-based outlines**:
  - Modified `transformers-parsing-adapter.ts` to convert segmentation masks to outline polygons
  - Added mask-to-outline conversion for brows, nose, eyes, and mouth regions
  - Uses `maskToOutline()` function with convex hull + RDP simplification
  - Outlines now follow actual segmented regions instead of falling back to crude landmark-based shapes
  - Removed TODO comment - segmentation-based outlines are now fully implemented
  - Visual overlays now display accurate contours derived from the SegFormer model
- **Integrated narrative descriptions with similarity scores in UI**:
  - Modified `ResultsPanel.tsx` to display narrative descriptions inline with their corresponding similarity scores
  - Descriptions now appear on the same line as the score with format: "region: 85.0% — description"
  - Uses em dash separator and reduced opacity for visual hierarchy
  - Eliminated separate list of descriptions for cleaner, more intuitive UI
- **Added narrative generation for segmentation scores**:
  - Created `lib/narrative.ts` with natural language descriptions for regional similarity
  - Generates context-aware text based on score thresholds (very-similar, similar, somewhat-similar, different, very-different)
  - Covers all segmentation regions: eyes, brows, nose, mouth, jaw, ears, skin, hair, neck, eyeglasses
  - Worker automatically uses narrative generator when segmentation masks are available
  - Falls back to landmark-based narrative text when masks unavailable
  - Added comprehensive unit tests (9 test cases) covering all similarity levels and edge cases
  - All tests passing (72/72 total, including 9 new narrative tests)
- **Excluded cloth region from similarity calculations**:
  - Modified `summarizeRegionsFromMasks` to filter out 'cloth' region before computing scores
  - Cloth is not a facial feature and was skewing similarity results
  - Overall similarity score now only considers facial features
- **Implemented segmentation-based similarity scoring**:
  - Created `lib/segmentation-scoring.ts` with mask-based regional similarity computation
  - Uses Dice coefficient for shape overlap (less sensitive than IoU to size differences)
  - Combines shape (60%), position (25%), and size (15%) metrics into final score
  - Worker automatically uses mask-based scoring when available (Transformers.js/ONNX adapters)
  - Falls back to Procrustes landmark scoring when masks unavailable (facemesh adapter)
  - Added comprehensive unit tests (23 test cases) covering IoU, Dice, centroid, area similarity
  - All tests passing (63/63 total, including 23 new segmentation tests)
- **Fixed canvas transfer bug that enabled segmentation**:
  - Moved `transferToImageBitmap()` call to AFTER `computeOutlinePolys()` in worker
  - Transfer operation detaches/empties canvas, so must compute segmentation first
  - This fix enabled both Transformers.js and ONNX Runtime adapters to work correctly
  - Updated adapter labels: "Transformers.js (SegFormer)", "ONNX Runtime (ResNet34)", "Landmarks only (MediaPipe)"
- **Added debugging discipline to AGENTS.md and CLAUDE.md**:
  - Read documentation first before guessing at APIs
  - Test code changes before suggesting them
  - Trace data flow to catch lifecycle bugs (transfer, detach, invalidation)
  - Ask for fresh logs rather than relying on stale debugging context
  - Check simple issues first (null values, timing, lifecycle) before complex debugging

## Done (recent debugging)
- **Fixed ONNX nose alias height constraint** (eleventh iteration - SUCCESS):
  - Identified that alias height check (segMaskHeight > heurHeightPx * 1.15) was causing fallback
  - Segmentation mask height (135.8px) was slightly exceeding the 1.15× limit (133.2px)
  - Relaxed constraint from 1.15× to 1.25× (new limit: 144.8px) to allow accurate ONNX segmentation to be used
  - Console now shows `[parsing] nose SUCCESS: using ONNX-based outline with 10 points`
  - ONNX face parsing model now successfully generates nose outlines following actual nose contours
  - Nose overlay now uses segmentation-derived teardrop shape instead of landmark-based approximation
- **Added ONNX nose debug logging** (tenth iteration):
  - Added console.info logs for rowCount, maskPixels, polyPixels, coverage, and required coverage
  - Added console.warn logs for each fallback condition (rowCount < 4, coverage too low, alias mask too tall, noseWidth too small)
  - Added console.info log for successful ONNX-based outline generation
  - Added alias height check logging (segMaskHeight, heurHeightPx, limit)
  - This helped identify the exact condition causing ONNX nose generation to fall back to heuristic teardrop

## Done
- **Use actual nose contour landmarks** (ninth iteration - abandon synthetic teardrop):
  - Nose: completely rewrote to use FEATURE_OUTLINES.nose[0] landmark sequence [94,19,98,4,2,309,331] which traces actual nose contour (left alar → nostril → near tip → tip apex → nostril → right alar); connect with bridge width at landmark 168; no more synthetic interpolation or quadratic formulas - just follow MediaPipe's anatomical landmarks
  - All tests passing (36/36)
- **Use mid-bridge landmark** (eighth iteration - shorten nose to visible region):
  - Nose: switched from bridgeRoot(6) to bridgeMid(168) as starting point; landmark 6 is too high (between eyebrows), while 168 is where visible nose bridge starts; this shortens the nose outline to match the actual visible nose region; increased bridge width to 15% of alar width for better visibility
  - All tests passing (36/36)
- **Centering and bridge width** (seventh iteration - fix off-center and pointy top):
  - Nose: calculate centerX from average of alar landmarks (more reliable than bridge landmark) to fix off-center issue; add explicit bridge width (10% of alar width) instead of single-point top; interpolate from bridge width to alar width using quadratic gradient; top now traces narrow bridge outline instead of connecting to sharp point
  - All tests passing (36/36)
- **Simplified nose path** (sixth iteration - three-segment teardrop):
  - Nose: removed nostril inner landmarks (19, 309) from path; now uses only bridge(6) → alar(94,331) → tip(1); three segments with separate interpolation: bridge→alar (4 steps, quadratic widening), alar→tip (2 steps, slight narrowing), tip→alar→bridge (mirrored); creates cleaner teardrop profile
  - All tests passing (36/36)
- **Critical shape refinement** (fifth iteration - quadratic width gradient and angular sorting):
  - Nose: implemented QUADRATIC width expansion (not linear) using widthFactor = t² to create true teardrop; interpolates from bridgeRoot(6) directly to alar with 5 steps per side; horizontal offset grows quadratically while vertical progresses linearly
  - Brows: changed from X-coordinate sorting to angular sorting (atan2 from eye center) to follow natural curved arc instead of straight horizontal progression; prevents "upside-down trapezoid" shape
  - All tests passing (36/36)
- **Refinement of landmark extraction** (fourth iteration - spatial sorting and no smoothing):
  - Brows: added spatial sorting (left-to-right by X coordinate) to MediaPipe's eyebrow landmarks to ensure smooth left-to-right arcs without zigzag
  - Nose: removed smoothCurve call (which was collapsing width gradient) and increased interpolation steps from 1 to 3 per side (t=0.25, 0.5, 0.75) for clearer teardrop shape progression
  - All tests passing (36/36)
- **Final landmark-based extraction** (third iteration - using actual eyebrow landmarks):
  - Brows: switched from derived upper-lid offsets to MediaPipe's dedicated eyebrow landmarks (FEATURE_OUTLINES.brows: left=[70,63,105,66,107,55,193,35,124], right=[300,293,334,296,336,285,417,265,353]); now shows full eyebrow arcs instead of short dashes
  - Nose: added proper width gradient with interpolated transition points; bridge(6) → mid-transition → widest at alar(94,331) → nostril inner(19,309) → tip(1) → nostril → alar → mid-transition → bridge for true teardrop
  - All tests passing (36/36)
- **Critical fixes to brow and nose extraction** (second iteration after visual feedback):
  - Brows: changed from radial offset to simple vertical (upward) offset by 18% of IPD; eliminated complex taper logic that was pushing brows inward toward pupils instead of upward toward forehead
  - Nose: rebuilt with explicit clockwise ordering (bridge → left alar → tip → right alar → bridge) and added small horizontal offsets (±5% IPD) at bridge mid-point to create width gradient for teardrop shape
  - All tests passing (36/36) after updating test expectations
- **Fixed brow and nose extraction issues** based on initial visual feedback:
  - Brows: increased lift from 5% to 15% of IPD for visibility; removed aggressive 80% trimming that was hiding brows; simplified taper to only affect extreme ends
  - Nose: rewritten as true teardrop (wide bottom, narrow top) using explicit landmark ordering: bridge(6,168) → left alar(94,98) → tip(1) → right alar(327,331) → bridge; eliminated centroid-based symmetry that caused diamond shape
  - All tests still passing (36/36)
- **Hybrid precision feature extraction (Option D)**: implemented landmark-based brow and nose extraction using MediaPipe's 468 landmarks for high-frequency features
  - Landmark-based brows: extract upper eyelid arcs, offset away from eye center with anatomical lift and parabolic taper, smooth with moving average
  - Landmark-based nose: use bridge (landmarks 6, 168) and alar landmarks (94, 19, 98, 327, 309, 331) to build anatomically accurate outline
  - Updated hints.ts to use landmark extraction as primary method with fallback to static contours
  - Updated parsing adapter to report 'landmarks' as source instead of 'heuristic' (clarifies that these are precision landmark-derived features, not crude geometric templates)
  - All tests passing (36/36) including new landmark-features.test.ts with coverage for brow extraction, nose extraction, and PCA-based curvature computation
  - Created landmark-features.ts module with smoothCurve, extractUpperLidArc, deriveBrowFromLid, extractLandmarkBrows, extractLandmarkNose, computeLocalCurvature functions
- Nose overlay: replaced triangle heuristic with segmentation-derived teardrop outline, added dev `?showMask=` overlay plumbing, and extended unit coverage for the new mask pipeline (`npm test`).
- Nose coverage widening: inflated the segmentation sampling window, broadened the teardrop outline with additional side/top anchors, and pruned debug masks to the clipped region so class `6` no longer floods the face (`npm test`).
- Nose fallback: when segmentation confidence is low (or only glasses class appears), fall back to a landmark-driven teardrop that respects nose bounds instead of stretching below the nostrils (`npm test`).
- Mask overlay debug: capture segmentation masks on every dev run, add UI toggle to select mask classes post-analysis, and update overlays/tests to honor the highlight without re-running analysis (`npm test`).
- Type hygiene: removed remaining `any` usages across src; added `DetectorImage` union type, typed ORT session metadata, output tensor guards, and replaced helper funcs with typed variants.
- Parsing adapter: added face-centered square crop (eye-based) before ORT and mapped outlines back to full image coordinates.
- Parsing adapter: selects best preprocessing attempt (layout/order/norm), merges ONNX-derived brows/nose hints with heuristics, and exposes env overrides for class IDs.
- Parsing adapter: allows brow/nose class aliases (glasses class 6 included by default) via env, clips segmentation to heuristic polygons to avoid large outlines, and added mocked coverage.
- Parsing adapter: clip segmentation masks to heuristic polygons, ensuring ORT outlines stay local (prevents big rectangles) and added mocked tests for the merge path.
- Dev log: show active adapter and parsing time per image in UI near the adapter toggle. Instrument worker to measure `regionHints` time and return `{adapter, parseMsA, parseMsB}`; page renders a small text log.
- E2E: added `e2e/ui-dev-log.spec.ts` to assert dev log visibility on `/`.
- Hydration: removed `suppressHydrationWarning` from dev log; element is mount-gated to avoid SSR/client mismatch.
- Dev log enhancement: show hints source (`onnx` or `heuristic`) per image when available.
- Parsing adapter: target package is `onnxruntime-web` (browser runtime); removed scoped alternative.
- ORT wiring: use literal dynamic import and explicit wasmPaths for jsep loader; docs note to copy `ort-wasm-simd-threaded.wasm` and `ort-wasm-simd-threaded.jsep.mjs` into `public/ort/`.
- Parsing IDs: switched tentative class IDs to CelebAMask-like mapping `{brows: 2/3, nose: 9}` and added a dev-only class histogram log to confirm labels.
- Output layout: parsing adapter now detects NHWC vs NCHW output tensors and computes argmax accordingly to avoid all-background masks.
- Input handling: detects input tensor layout from session metadata; tries RGB first, then flips layout and channel order to BGR if needed before falling back, to avoid background-only results.
- Output selection: when multiple outputs exist, pick the tensor that matches [1,K,H,W] or [1,H,W,K] (K>1, H/W≈S) before decoding to labels.
- Stage verification: project is in Stage 2 (workerized analysis, health route, PWA shell, E2E smoke present).
- Added unit tests:
  - `src/__tests__/summaries.test.ts`
  - `src/__tests__/offset-polygon.test.ts`
- Verified green suites:
  - `npm test`
  - `npm run e2e` and `npm run e2e:deep`

## Prospective Plan - Feature Selection & Stroking
- Detector upgrades
  - Keep `getDetector()` stable but allow alternative adapters (TFJS/ONNX) in `web/src/models/`.
  - Pin compatible versions; run both smoke tests after any bump.
- Eyebrows via parsing (expected-looking arcs)
  - Add a face-parsing/segmentation adapter (future `face-parsing-adapter.ts`).
  - Extract eyebrow masks ? contour ? medial curve; smooth and draw as short open arcs.
  - Gate new path behind a flag, fallback to current static outlines.
- Nose enrichment
  - Prefer parsing or higher-fidelity landmark sets to extract alar contours + bridge with confidence gating.
  - Replace current fallback nose sequence when parsing is available.
- 3D normalization
  - Estimate head pose from landmarks; canonicalize before curve extraction to reduce foreshortening.
  - Keep regional similarity in normalized space (already using `normalizeByEyes`).
- Confidence-aware rendering
  - Use per-landmark (or mask) confidence to prune/smooth and to adjust stroke alpha/width in `ImageOverlayPanel.tsx`.
- Similarity-driven styling
  - Map region similarity ? color + width (already partially in place); refine scale/ticks and add a legend.
- Tests and smoke
  - Keep `/health/detector` client-only and fast.
  - Add lightweight unit tests for new adapters and curve extraction; avoid flaky visual snapshots.
- Acceptance
  - Brows: compact arcs above each eye, no temple-length sweeps.
  - Nose: clean alar curve + short bridge, stable across roll/yaw.
  - All unit + smoke tests green.


## Now (overlay follow-ups)
- Visual QA: validate new overlay shapes on varied samples; consider tuning brow crop fraction (0.85) and max radius cap (0.28xIPD), and nose bridge length.

## Done (recent)
- Added tests: src/__tests__/eye-center.test.ts, src/__tests__/regions-shape.test.ts.
- Overlay improvements: jaw concave-hull bottom chain; brows from static contours (central crop); nose alar arc + short bridge; similarity-colored strokes and reduced tension.
